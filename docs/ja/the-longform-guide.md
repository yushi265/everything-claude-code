# Everything Claude Codeの詳細ガイド

![ヘッダー: Everything Claude Codeの詳細ガイド](../../assets/images/longform/01-header.png)

---

> **前提条件**: このガイドは[Everything Claude Codeの簡易ガイド](./the-shortform-guide.md)を基礎としています。スキル、フック、サブエージェント、MCP、プラグインの設定がまだの方は、先にそちらをお読みください。

![簡易ガイドへの参照](../../assets/images/longform/02-shortform-reference.png)
*簡易ガイド - 先にお読みください*

簡易ガイドでは、基礎的なセットアップについて説明しました。スキルとコマンド、フック、サブエージェント、MCP、プラグイン、そして効果的なClaude Codeワークフローの骨格を形成する設定パターンです。あれはセットアップガイドであり、基盤インフラでした。

この詳細ガイドでは、生産的なセッションと無駄なセッションを分ける技術に踏み込みます。簡易ガイドをまだ読んでいない場合は、まず設定を行ってください。以下の内容は、スキル、エージェント、フック、MCPがすでに設定され、動作していることを前提としています。

ここでのテーマは、トークン経済学、メモリの永続化、検証パターン、並列化戦略、そして再利用可能なワークフローを構築することによる複利効果です。これらは、最初の1時間以内にコンテキストの腐敗に悩まされることなく、何時間も生産的なセッションを維持できるようにする、10ヶ月以上の日常使用で洗練されたパターンです。

簡易ガイドと詳細ガイドで取り上げたすべての内容は、GitHubで公開されています: `github.com/affaan-m/everything-claude-code`

---

## ヒントとコツ

### 一部のMCPは置き換え可能でコンテキストウィンドウを解放できる

バージョン管理（GitHub）、データベース（Supabase）、デプロイ（Vercel、Railway）などのMCPについて - これらのプラットフォームのほとんどは、MCPが本質的にラップしているだけの堅牢なCLIをすでに持っています。MCPは便利なラッパーですが、コストがかかります。

MCPを実際に使用せず（そしてそれに伴うコンテキストウィンドウの減少なしに）CLIをMCPのように機能させるには、機能をスキルやコマンドにバンドルすることを検討してください。MCPが公開している、物事を簡単にするツールを取り除き、それらをコマンドに変換します。

例: GitHub MCPを常時ロードする代わりに、好みのオプションで`gh pr create`をラップする`/gh-pr`コマンドを作成します。Supabase MCPにコンテキストを食われる代わりに、Supabase CLIを直接使用するスキルを作成します。

遅延読み込みにより、コンテキストウィンドウの問題はほぼ解決されています。しかし、トークン使用量とコストは同じようには解決されていません。CLI + スキルアプローチは、依然としてトークン最適化の方法です。

---

## 重要なこと

### コンテキストとメモリの管理

セッション間でメモリを共有するには、進捗状況を要約してチェックし、`.claude`フォルダ内の`.tmp`ファイルに保存し、セッション終了まで追記していくスキルまたはコマンドが最適です。翌日はそれをコンテキストとして使用し、中断したところから再開できます。古いコンテキストが新しい作業に混入しないように、セッションごとに新しいファイルを作成してください。

![セッションストレージのファイルツリー](../../assets/images/longform/03-session-storage.png)
*セッションストレージの例 → https://github.com/affaan-m/everything-claude-code/tree/main/examples/sessions*

Claudeが現在の状態を要約したファイルを作成します。それをレビューし、必要に応じて編集を依頼してから、新たに開始します。新しい会話では、ファイルパスを提供するだけです。コンテキストの制限に達し、複雑な作業を続ける必要がある場合に特に便利です。これらのファイルには以下を含める必要があります:
- 機能したアプローチ（証拠を伴って検証可能なもの）
- 試みたが機能しなかったアプローチ
- まだ試していないアプローチと残っている作業

**戦略的なコンテキストのクリア:**

プランを設定してコンテキストをクリアした後（Claude Codeのプランモードでデフォルトのオプション）、プランから作業できます。これは、実行に関連しなくなった多くの探索コンテキストを蓄積した場合に便利です。戦略的な圧縮のために、自動圧縮を無効にします。論理的な間隔で手動で圧縮するか、それを行うスキルを作成します。

**高度: 動的システムプロンプトインジェクション**

私が取り入れたパターンの1つ: 毎回セッションでロードされるCLAUDE.md（ユーザースコープ）または`.claude/rules/`（プロジェクトスコープ）にすべてを入れるのではなく、CLIフラグを使用してコンテキストを動的に注入します。

```bash
claude --system-prompt "$(cat memory.md)"
```

これにより、どのコンテキストをいつロードするかについて、より外科的に対処できます。システムプロンプトの内容は、ユーザーメッセージよりも高い権限を持ち、ユーザーメッセージはツール結果よりも高い権限を持ちます。

**実用的なセットアップ:**

```bash
# 日常的な開発
alias claude-dev='claude --system-prompt "$(cat ~/.claude/contexts/dev.md)"'

# PRレビューモード
alias claude-review='claude --system-prompt "$(cat ~/.claude/contexts/review.md)"'

# 研究/探索モード
alias claude-research='claude --system-prompt "$(cat ~/.claude/contexts/research.md)"'
```

**高度: メモリ永続化フック**

メモリに役立つ、ほとんどの人が知らないフックがあります:

- **PreCompactフック**: コンテキストの圧縮が発生する前に、重要な状態をファイルに保存
- **Stopフック（セッション終了）**: セッション終了時に、学習内容をファイルに永続化
- **SessionStartフック**: 新しいセッション開始時に、以前のコンテキストを自動的にロード

これらのフックを構築しており、`github.com/affaan-m/everything-claude-code/tree/main/hooks/memory-persistence`のリポジトリにあります。

---

### 継続的学習 / メモリ

プロンプトを何度も繰り返さなければならず、Claudeが同じ問題に遭遇したり、以前に聞いた応答をした場合 - それらのパターンはスキルに追加する必要があります。

**問題:** トークン、コンテキスト、時間の無駄。

**解決策:** Claude Codeが自明でないこと - デバッグ技術、回避策、プロジェクト固有のパターン - を発見したとき、その知識を新しいスキルとして保存します。次回同様の問題が発生したとき、スキルが自動的にロードされます。

私は、これを行う継続的学習スキルを構築しました: `github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning`

**なぜStopフック（UserPromptSubmitではなく）:**

重要な設計上の決定は、UserPromptSubmitではなく**Stopフック**を使用することです。UserPromptSubmitはすべてのメッセージで実行されます - すべてのプロンプトにレイテンシが追加されます。Stopはセッション終了時に1回実行されます - 軽量で、セッション中の速度を低下させません。

---

### トークンの最適化

**主要戦略: サブエージェントアーキテクチャ**

使用するツールとサブエージェントアーキテクチャを最適化し、タスクに十分な最も安価なモデルに委任するように設計します。

**モデル選択クイックリファレンス:**

![モデル選択表](../../assets/images/longform/04-model-selection.png)
*一般的なタスクでのサブエージェントの仮想的なセットアップと選択の根拠*

| タスクタイプ | モデル | 理由 |
| ------------------------- | ------ | ------------------------------------------ |
| 探索/検索 | Haiku | 高速、安価、ファイル検索に十分 |
| 簡単な編集 | Haiku | 単一ファイルの変更、明確な指示 |
| 複数ファイルの実装 | Sonnet | コーディングに最適なバランス |
| 複雑なアーキテクチャ | Opus | 深い推論が必要 |
| PRレビュー | Sonnet | コンテキストを理解し、ニュアンスをキャッチ |
| セキュリティ分析 | Opus | 脆弱性を見逃すわけにはいかない |
| ドキュメント作成 | Haiku | 構造はシンプル |
| 複雑なバグのデバッグ | Opus | システム全体を念頭に置く必要がある |

コーディングタスクの90%にはSonnetをデフォルトで使用します。最初の試行が失敗した場合、タスクが5つ以上のファイルにまたがる場合、アーキテクチャ上の決定、またはセキュリティクリティカルなコードの場合は、Opusにアップグレードします。

**価格リファレンス:**

![Claudeモデルの価格](../../assets/images/longform/05-pricing-table.png)
*出典: https://platform.claude.com/docs/en/about-claude/pricing*

**ツール固有の最適化:**

grepをmgrepに置き換える - 従来のgrepやripgrepと比較して平均約50%のトークン削減:

![mgrepベンチマーク](../../assets/images/longform/06-mgrep-benchmark.png)
*50タスクのベンチマークでは、mgrep + Claude Codeはgrepベースのワークフローと比較して約2倍少ないトークンを使用し、同等またはそれ以上の品質と判断されました。出典: https://github.com/mixedbread-ai/mgrep*

**モジュール化されたコードベースのメリット:**

メインファイルが数千行ではなく数百行のより モジュール化されたコードベースを持つことは、トークン最適化のコストと最初の試行でタスクを正しく完了させることの両方に役立ちます。

---

### 検証ループとEval

**ベンチマーキングワークフロー:**

スキルの有無で同じことを求め、出力の違いをチェックすることを比較します:

会話をフォークし、スキルなしで一方に新しいワークツリーを開始し、最後にdiffを取得し、何がログされたかを確認します。

**Evalパターンタイプ:**

- **チェックポイントベースのEval**: 明示的なチェックポイントを設定し、定義された基準に対して検証し、進む前に修正
- **継続的なEval**: N分ごとまたは大きな変更後に実行、完全なテストスイート + lint

**主要な指標:**

```
pass@k: k回の試行のうち少なくとも1回成功
        k=1: 70%  k=3: 91%  k=5: 97%

pass^k: k回の試行すべてが成功する必要がある
        k=1: 70%  k=3: 34%  k=5: 17%
```

単に動作すればよい場合は**pass@k**を使用します。一貫性が不可欠な場合は**pass^k**を使用します。

---

## 並列化

マルチClaudeターミナルセットアップで会話をフォークする場合、フォークと元の会話のアクションのスコープが明確に定義されていることを確認してください。コード変更に関しては、最小限の重複を目指します。

**私の好みのパターン:**

コード変更にはメインチャット、コードベースとその現在の状態についての質問や外部サービスの調査にはフォークを使用します。

**任意のターミナル数について:**

![並列ターミナルに関するBoris](../../assets/images/longform/07-boris-parallel.png)
*複数のClaudeインスタンスの実行に関するBoris（Anthropic）*

Borisは並列化についてのヒントを持っています。彼は、5つのClaudeインスタンスをローカルで実行し、5つをアップストリームで実行するようなことを提案しています。任意のターミナル数を設定することはお勧めしません。ターミナルの追加は、真の必要性から行うべきです。

あなたの目標は次のとおりです: **最小限の実行可能な並列化量で、どれだけ達成できるか。**

**並列インスタンス用のGitワークツリー:**

```bash
# 並列作業用のワークツリーを作成
git worktree add ../project-feature-a feature-a
git worktree add ../project-feature-b feature-b
git worktree add ../project-refactor refactor-branch

# 各ワークツリーに独自のClaudeインスタンスを持たせる
cd ../project-feature-a && claude
```

インスタンスのスケーリングを開始する場合、かつ、互いに重複するコードで作業する複数のClaudeインスタンスがある場合、gitワークツリーを使用し、それぞれに対して非常に明確に定義されたプランを持つことが不可欠です。`/rename <name here>`を使用してすべてのチャットに名前を付けます。

![2つのターミナルセットアップ](../../assets/images/longform/08-two-terminals.png)
*開始セットアップ: コーディング用の左ターミナル、質問用の右ターミナル - /renameと/forkを使用*

**カスケード方式:**

複数のClaude Codeインスタンスを実行する場合、「カスケード」パターンで整理します:

- 新しいタスクを右側の新しいタブで開く
- 左から右へ、古いものから新しいものへスイープ
- 一度に最大3〜4のタスクに集中

---

## 基礎作業

**2インスタンスキックオフパターン:**

私自身のワークフロー管理のために、空のリポジトリを2つのオープンなClaudeインスタンスで開始するのが好きです。

**インスタンス1: 足場エージェント**
- 足場と基礎作業を敷設
- プロジェクト構造を作成
- 設定をセットアップ（CLAUDE.md、ルール、エージェント）

**インスタンス2: 深い調査エージェント**
- すべてのサービス、ウェブ検索に接続
- 詳細なPRDを作成
- アーキテクチャのmermaid図を作成
- 実際のドキュメントクリップを使用してリファレンスをコンパイル

**llms.txtパターン:**

利用可能な場合、多くのドキュメントリファレンスで、ドキュメントページに到達したら`/llms.txt`を実行することで`llms.txt`を見つけることができます。これにより、LLM向けに最適化されたクリーンなバージョンのドキュメントが提供されます。

**哲学: 再利用可能なパターンを構築する**

@omarsar0から: 「早い段階で、再利用可能なワークフロー/パターンの構築に時間を費やしました。構築するのは面倒でしたが、モデルとエージェントハーネスが改善されるにつれて、これは野生の複利効果をもたらしました。」

**投資すべきもの:**

- サブエージェント
- スキル
- コマンド
- プランニングパターン
- MCPツール
- コンテキストエンジニアリングパターン

---

## エージェントとサブエージェントのベストプラクティス

**サブエージェントのコンテキスト問題:**

サブエージェントは、すべてをダンプする代わりに要約を返すことでコンテキストを節約するために存在します。しかし、オーケストレーターはサブエージェントが欠いているセマンティックコンテキストを持っています。サブエージェントはリテラルなクエリのみを知っており、リクエストの背後にある目的を知りません。

**反復取得パターン:**

1. オーケストレーターはすべてのサブエージェントの戻り値を評価
2. 受け入れる前にフォローアップの質問をする
3. サブエージェントはソースに戻り、回答を取得し、返す
4. 十分になるまでループ（最大3サイクル）

**鍵:** クエリだけでなく、目的のコンテキストを渡す。

**シーケンシャルフェーズのオーケストレーター:**

```markdown
フェーズ1: 調査（Exploreエージェントを使用）→ research-summary.md
フェーズ2: プラン（plannerエージェントを使用）→ plan.md
フェーズ3: 実装（tdd-guideエージェントを使用）→ コードの変更
フェーズ4: レビュー（code-reviewerエージェントを使用）→ review-comments.md
フェーズ5: 検証（必要に応じてbuild-error-resolverを使用）→ 完了またはループバック
```

**主要なルール:**

1. 各エージェントは1つの明確な入力を取得し、1つの明確な出力を生成
2. 出力は次のフェーズの入力になる
3. フェーズをスキップしない
4. エージェント間で`/clear`を使用
5. 中間出力をファイルに保存

---

## 楽しいもの / クリティカルではない単なる楽しいヒント

### カスタムステータスライン

`/statusline`を使用して設定できます - するとClaudeはまだ持っていないが、セットアップできるので、何を入れたいか尋ねます。

参照: https://github.com/sirmalloc/ccstatusline

### 音声文字起こし

Claude Codeに音声で話しかけます。多くの人にとってタイピングよりも速いです。

- Mac上のsuperwhisper、MacWhisper
- 文字起こしの間違いがあっても、Claudeは意図を理解します

### ターミナルエイリアス

```bash
alias c='claude'
alias gb='github'
alias co='code'
alias q='cd ~/Desktop/projects'
```

---

## マイルストーン

![25k以上のGitHub Star](../../assets/images/longform/09-25k-stars.png)
*1週間以内に25,000以上のGitHub Star*

---

## リソース

**エージェントオーケストレーション:**

- https://github.com/ruvnet/claude-flow - 54以上の専門エージェントを持つエンタープライズオーケストレーションプラットフォーム

**自己改善メモリ:**

- https://github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning
- rlancemartin.github.io/2025/12/01/claude_diary/ - セッション反映パターン

**システムプロンプトリファレンス:**

- https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools - システムプロンプトのコレクション（110k stars）

**公式:**

- Anthropic Academy: anthropic.skilljar.com

---

## 参考文献

- [Anthropic: AIエージェントのEvalの謎を解く](https://www.anthropic.com/engineering/demystifying-evals-for-ai-agents)
- [YK: 32のClaude Codeヒント](https://agenticcoding.substack.com/p/32-claude-code-tips-from-basics-to)
- [RLanceMartin: セッション反映パターン](https://rlancemartin.github.io/2025/12/01/claude_diary/)
- @PerceptualPeak: サブエージェントコンテキストネゴシエーション
- @menhguin: エージェント抽象化階層リスト
- @omarsar0: 複利効果の哲学

---

*両方のガイドで取り上げたすべての内容は、GitHubの[everything-claude-code](https://github.com/affaan-m/everything-claude-code)で公開されています*
