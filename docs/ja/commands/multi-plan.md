# Plan - マルチモデル協調計画

マルチモデル協調計画 - コンテキスト取得 + デュアルモデル分析 → ステップバイステップの実装計画を生成。

$ARGUMENTS

---

## コアプロトコル

- **言語プロトコル**: ツール/モデルと対話するときは**英語**を使用、ユーザーとはユーザーの言語でコミュニケーション
- **必須並列**: Codex/Gemini 呼び出しは `run_in_background: true` を使用する必要あり（単一モデル呼び出しも含む、メインスレッドをブロックしないため）
- **コード主権**: 外部モデルは**ファイルシステムへの書き込みアクセスがゼロ**、すべての変更は Claude が実行
- **損失制限メカニズム**: 現在のフェーズの出力が検証されるまで次のフェーズに進まない
- **計画のみ**: このコマンドはコンテキストの読み取りと `.claude/plan/*` 計画ファイルへの書き込みを許可しますが、**プロダクションコードは絶対に変更しない**

---

## マルチモデル呼び出し仕様

**呼び出し構文**（並列: `run_in_background: true` を使用）:

```
Bash({
  command: "~/.claude/bin/codeagent-wrapper {{LITE_MODE_FLAG}}--backend <codex|gemini> {{GEMINI_MODEL_FLAG}}- \"$PWD\" <<'EOF'
ROLE_FILE: <ロールプロンプトパス>
<TASK>
Requirement: <強化された要件>
Context: <取得したプロジェクトコンテキスト>
</TASK>
OUTPUT: 疑似コード付きステップバイステップの実装計画。ファイルを変更しないでください。
EOF",
  run_in_background: true,
  timeout: 3600000,
  description: "Brief description"
})
```

**モデルパラメータのノート**:
- `{{GEMINI_MODEL_FLAG}}`: `--backend gemini` を使用する場合、`--gemini-model gemini-3-pro-preview ` に置き換える（末尾のスペースに注意）。codex の場合は空文字列を使用

**ロールプロンプト**:

| フェーズ | Codex | Gemini |
|-------|-------|--------|
| 分析 | `~/.claude/.ccg/prompts/codex/analyzer.md` | `~/.claude/.ccg/prompts/gemini/analyzer.md` |
| 計画 | `~/.claude/.ccg/prompts/codex/architect.md` | `~/.claude/.ccg/prompts/gemini/architect.md` |

**セッションの再利用**: 各呼び出しは `SESSION_ID: xxx` を返します（通常はラッパーによって出力されます）。後続の `/ccg:execute` 使用のために**保存する必要があります**。

**バックグラウンドタスクを待つ**（最大タイムアウト 600000ms = 10 分）:

```
TaskOutput({ task_id: "<task_id>", block: true, timeout: 600000 })
```

**重要**:
- `timeout: 600000` を指定する必要があります。そうしないとデフォルトの 30 秒で早期タイムアウトします
- 10 分後も不完全な場合は、`TaskOutput` でポーリングを続けます。**絶対にプロセスを kill しない**
- タイムアウトによりスキップされた場合は、**ユーザーに待ち続けるかタスクを kill するか尋ねる `AskUserQuestion` を呼び出す必要あり**

---

## 実行ワークフロー

**計画タスク**: $ARGUMENTS

### フェーズ 1: 完全なコンテキスト取得

`[Mode: Research]`

#### 1.1 プロンプト強化（最初に実行必須）

**`mcp__ace-tool__enhance_prompt` ツールを呼び出す必要があります**:

```
mcp__ace-tool__enhance_prompt({
  prompt: "$ARGUMENTS",
  conversation_history: "<最後の 5-10 会話ターン>",
  project_root_path: "$PWD"
})
```

強化されたプロンプトを待ち、**後続のすべてのフェーズのために元の $ARGUMENTS を強化結果で置き換えます**。

#### 1.2 コンテキスト取得

**`mcp__ace-tool__search_context` ツールを呼び出す**:

```
mcp__ace-tool__search_context({
  query: "<強化された要件に基づくセマンティッククエリ>",
  project_root_path: "$PWD"
})
```

- 自然言語を使用してセマンティッククエリを構築（Where/What/How）
- **絶対に仮定に基づいて答えない**
- MCP が利用できない場合: Glob + Grep にフォールバックしてファイル発見とキーシンボルの場所を特定

#### 1.3 完全性チェック

- 関連するクラス、関数、変数の**完全な定義とシグネチャ**を取得する必要あり
- コンテキストが不十分な場合、**再帰的取得**をトリガー
- 出力の優先順位: エントリーファイル + 行番号 + キーシンボル名; 曖昧さを解消するために必要な場合のみ最小限のコードスニペットを追加

#### 1.4 要件の整合性

- 要件にまだ曖昧さがある場合、**ユーザーのためのガイド質問を出力する必要あり**
- 要件の境界が明確になるまで（省略なし、冗長性なし）

### フェーズ 2: マルチモデル協調分析

`[Mode: Analysis]`

#### 2.1 入力を分配

**並列呼び出し** Codex と Gemini（`run_in_background: true`）:

両方のモデルに**元の要件**（プリセットの意見なし）を分配:

1. **Codex バックエンド分析**:
   - ROLE_FILE: `~/.claude/.ccg/prompts/codex/analyzer.md`
   - 焦点: 技術的実現可能性、アーキテクチャへの影響、パフォーマンスの考慮事項、潜在的なリスク
   - OUTPUT: 多角的なソリューション + 長所/短所の分析

2. **Gemini フロントエンド分析**:
   - ROLE_FILE: `~/.claude/.ccg/prompts/gemini/analyzer.md`
   - 焦点: UI/UX への影響、ユーザーエクスペリエンス、ビジュアルデザイン
   - OUTPUT: 多角的なソリューション + 長所/短所の分析

`TaskOutput` で両方のモデルの完全な結果を待ちます。**SESSION_ID を保存**（`CODEX_SESSION` と `GEMINI_SESSION`）。

#### 2.2 クロスバリデーション

視点を統合し、最適化のために反復:

1. **コンセンサスを特定**（強いシグナル）
2. **分岐を特定**（重み付けが必要）
3. **補完的な強み**: バックエンドロジックは Codex に従い、フロントエンドデザインは Gemini に従う
4. **論理的推論**: ソリューションの論理的なギャップを排除

#### 2.3（オプションだが推奨）デュアルモデル計画ドラフト

Claude の統合計画での省略のリスクを減らすために、両方のモデルに並列で「計画ドラフト」を出力させることができます（まだファイルを変更することは**許可されていません**）:

1. **Codex 計画ドラフト**（バックエンドの権威）:
   - ROLE_FILE: `~/.claude/.ccg/prompts/codex/architect.md`
   - OUTPUT: ステップバイステップの計画 + 疑似コード（焦点: データフロー/エッジケース/エラーハンドリング/テスト戦略）

2. **Gemini 計画ドラフト**（フロントエンドの権威）:
   - ROLE_FILE: `~/.claude/.ccg/prompts/gemini/architect.md`
   - OUTPUT: ステップバイステップの計画 + 疑似コード（焦点: 情報アーキテクチャ/インタラクション/アクセシビリティ/ビジュアルの一貫性）

`TaskOutput` で両方のモデルの完全な結果を待ち、提案の主な違いを記録します。

#### 2.4 実装計画を生成（Claude 最終版）

両方の分析を統合し、**ステップバイステップの実装計画**を生成:

```markdown
## 実装計画: <タスク名>

### タスクタイプ
- [ ] Frontend（→ Gemini）
- [ ] Backend（→ Codex）
- [ ] Fullstack（→ 並列）

### 技術的ソリューション
<Codex + Gemini 分析から統合された最適なソリューション>

### 実装ステップ
1. <ステップ 1> - 期待される成果物
2. <ステップ 2> - 期待される成果物
...

### キーファイル
| ファイル | 操作 | 説明 |
|------|-----------|-------------|
| path/to/file.ts:L10-L50 | 変更 | 説明 |

### リスクと軽減策
| リスク | 軽減策 |
|------|------------|

### SESSION_ID（/ccg:execute 使用のため）
- CODEX_SESSION: <session_id>
- GEMINI_SESSION: <session_id>
```

### フェーズ 2 終了: 計画配信（実行ではない）

**`/ccg:plan` の責任はここで終了、次のアクションを実行する必要があります**:

1. 完全な実装計画をユーザーに提示（疑似コードを含む）
2. 計画を `.claude/plan/<feature-name>.md` に保存（要件から機能名を抽出、例: `user-auth`、`payment-module`）
3. **太字テキスト**でプロンプトを出力（実際に保存されたファイルパスを使用する必要あり）:

   ---
   **計画が生成され、`.claude/plan/actual-feature-name.md` に保存されました**

   **上記の計画をレビューしてください。次のことができます:**
   - **計画を変更**: 調整が必要な点を教えてください、計画を更新します
   - **計画を実行**: 次のコマンドを新しいセッションにコピーしてください

   ```
   /ccg:execute .claude/plan/actual-feature-name.md
   ```
   ---

   **注意**: 上記の `actual-feature-name.md` は実際に保存されたファイル名に置き換える必要があります！

4. **現在の応答を即座に終了**（ここで停止。これ以上のツール呼び出しはありません。）

**絶対に禁止**:
- ユーザーに「Y/N」と尋ねてから自動実行（実行は `/ccg:execute` の責任）
- プロダクションコードへの書き込み操作
- `/ccg:execute` または任意の実装アクションを自動的に呼び出す
- ユーザーが明示的に変更を要求していないときにモデル呼び出しをトリガーし続ける

---

## 計画の保存

計画が完了した後、計画を次の場所に保存:

- **最初の計画**: `.claude/plan/<feature-name>.md`
- **反復バージョン**: `.claude/plan/<feature-name>-v2.md`、`.claude/plan/<feature-name>-v3.md`...

計画ファイルの書き込みは、ユーザーに計画を提示する前に完了する必要があります。

---

## 計画変更フロー

ユーザーが計画の変更を要求した場合:

1. ユーザーのフィードバックに基づいて計画内容を調整
2. `.claude/plan/<feature-name>.md` ファイルを更新
3. 変更された計画を再提示
4. ユーザーに再度レビューまたは実行を促す

---

## 次のステップ

ユーザーが承認した後、**手動で**実行:

```bash
/ccg:execute .claude/plan/<feature-name>.md
```

---

## 重要なルール

1. **計画のみ、実装なし** – このコマンドはコード変更を実行しません
2. **Y/N プロンプトなし** – 計画のみを提示し、ユーザーに次のステップを決定させます
3. **信頼ルール** – バックエンドは Codex に従い、フロントエンドは Gemini に従う
4. 外部モデルは **ファイルシステムへの書き込みアクセスがゼロ**
5. **SESSION_ID ハンドオフ** – 計画の最後に `CODEX_SESSION` / `GEMINI_SESSION` を含める必要あり（`/ccg:execute resume <SESSION_ID>` 使用のため）
